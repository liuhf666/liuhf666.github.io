<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="光阴似箭 岁月如梭 时光荏苒,转眼即逝。"><title>Vue项目性能优化方案 | Monster</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="/css/dark.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Vue项目性能优化方案</h1><a id="logo" href="/.">Monster</a><p class="description">long long ago..</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Vue项目性能优化方案</h1><div class="post-meta">2021-07-22<span> | </span><span class="category"><a href="/categories/Vue/">Vue</a></span></div><a class="disqus-comment-count" data-disqus-identifier="2021/07/22/Vue项目性能优化方案/" href="/2021/07/22/Vue%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">代码层面的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#v-if%E5%92%8Cv-show%E5%8C%BA%E5%88%86%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.1.</span> <span class="toc-text">v-if和v-show区分使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#computed%E5%92%8Cwatch%E5%8C%BA%E5%88%86%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.2.</span> <span class="toc-text">computed和watch区分使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-for%E9%81%8D%E5%8E%86%E5%BF%85%E9%A1%BB%E4%B8%BAitem%E6%B7%BB%E5%8A%A0key%EF%BC%8C%E4%B8%94%E9%81%BF%E5%85%8D%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8v-if"><span class="toc-number">2.3.</span> <span class="toc-text">v-for遍历必须为item添加key，且避免同时使用v-if</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%BF%E5%88%97%E8%A1%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">2.4.</span> <span class="toc-text">长列表性能优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%94%80%E6%AF%81"><span class="toc-number">2.5.</span> <span class="toc-text">事件的销毁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.6.</span> <span class="toc-text">图片资源懒加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.7.</span> <span class="toc-text">路由懒加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6%E7%9A%84%E6%8C%89%E9%9C%80%E5%BC%95%E5%85%A5"><span class="toc-number">2.8.</span> <span class="toc-text">第三方插件的按需引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%97%A0%E9%99%90%E5%88%97%E8%A1%A8%E6%80%A7%E8%83%BD"><span class="toc-number">2.9.</span> <span class="toc-text">优化无限列表性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93SSR-or-%E9%A2%84%E6%B8%B2%E6%9F%93"><span class="toc-number">2.10.</span> <span class="toc-text">服务端渲染SSR or 预渲染</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Webpack%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">Webpack层面的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Webpack%E5%AF%B9%E5%9B%BE%E7%89%87%E8%BF%9B%E8%A1%8C%E5%8E%8B%E7%BC%A9"><span class="toc-number">3.1.</span> <span class="toc-text">Webpack对图片进行压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%8F%E5%B0%91ES6%E8%BD%AC%E4%B8%BAES5%E7%9A%84%E4%BA%A2%E4%BD%99%E4%BB%A3%E7%A0%81"><span class="toc-number">3.2.</span> <span class="toc-text">减少ES6转为ES5的亢余代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E5%85%AC%E5%85%B1%E4%BB%A3%E7%A0%81"><span class="toc-number">3.3.</span> <span class="toc-text">提取公共代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc-number">3.4.</span> <span class="toc-text">模板预编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E7%BB%84%E4%BB%B6%E7%9A%84CSS"><span class="toc-number">3.5.</span> <span class="toc-text">提取组件的CSS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-SourceMap"><span class="toc-number">3.6.</span> <span class="toc-text">优化 SourceMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%E5%88%86%E6%9E%90"><span class="toc-number">3.7.</span> <span class="toc-text">构建结果输出分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96"><span class="toc-number">3.8.</span> <span class="toc-text">Vue项目的编译优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9A%84Web%E6%8A%80%E6%9C%AF%E4%BC%98%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">基础的Web技术优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%90%AFgzip%E5%8E%8B%E7%BC%A9"><span class="toc-number">4.1.</span> <span class="toc-text">开启gzip压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98"><span class="toc-number">4.2.</span> <span class="toc-text">浏览器缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CDN-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.</span> <span class="toc-text">CDN 的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Chrome-Performance-%E6%9F%A5%E6%89%BE%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88"><span class="toc-number">4.4.</span> <span class="toc-text">使用 Chrome Performance 查找性能瓶颈</span></a></li></ol></li></ol></div></div><div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Vue框架通过数据双向绑定和虚拟DOM技术，帮我们处理了前端开发中最脏最累的DOM操作部分，我们不在需要去考虑如何操作DOM以及如何最高效地操作DOM；但Vue项目中仍然存在项目首屏优化、Webpack编译配置优化等问题，所以我们仍然需要去关注Vue项目性能方面的优化，使项目具有更高效的性能、更好的用户体验。本文是通过实际项目的优化实践进行总结而来，希望读完之后，有一点的启发思考，从而对自己的项目进行优化起到帮助。本文内容分为以下三部分组成：<br>    Vue代码层面的优化；<br>    webpack配置层面的优化；<br>    基础的web技术层面的优化。</p>
<h3 id="代码层面的优化"><a href="#代码层面的优化" class="headerlink" title="代码层面的优化"></a>代码层面的优化</h3><h4 id="v-if和v-show区分使用场景"><a href="#v-if和v-show区分使用场景" class="headerlink" title="v-if和v-show区分使用场景"></a>v-if和v-show区分使用场景</h4><p><code>v-if</code>是<code>真正</code>的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是<code>惰性</code>的：如果再初始渲染时条件为假，则什么也不会做—-直到条件第一次变为真时，才会开始渲染条件块。<br><code>v-show</code>就简单得多，不管初始条件是什么，元素总是会被渲染，并且只是简单地基于CSS的display属性进行切换。<br>所以，v-if适用于在运行时很少改变条件，不需要频繁切换条件的场景；<br>v-show则适用于需要非常频繁切换条件的场景。</p>
<h4 id="computed和watch区分使用场景"><a href="#computed和watch区分使用场景" class="headerlink" title="computed和watch区分使用场景"></a>computed和watch区分使用场景</h4><p><code>computed</code>：是计算属性，依赖其它属性值，并且computed的值有缓存，只有它依赖的属性值发生改变，下一次获取computed的值时才会重新计算computed的值；<br><code>watch</code>：更多的是【观察】的作用，类似于某些数据的监听回调，每当监听的数据变化是都会执行回调进行后续操作；<br>运用场景：<br>    当我们需要进行数值计算，并且依赖于其他数据时，应该使用computed，因此可以利用computed的缓存特性，避免每次获取值时，都要重新计算；<br>    当我们需要在数据变化是执行异步或开销比较大的操作时，应该使用watch，使用watch选项允许我们执行异步操作（访问一个API），限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>
<h4 id="v-for遍历必须为item添加key，且避免同时使用v-if"><a href="#v-for遍历必须为item添加key，且避免同时使用v-if" class="headerlink" title="v-for遍历必须为item添加key，且避免同时使用v-if"></a>v-for遍历必须为item添加key，且避免同时使用v-if</h4><p>(1) v-for遍历必须为item添加key<br>在列表数据进行遍历渲染时，需要为每一项item设置唯一key值，方便Vue.js内部机制精准找到该条列表数据。当state更新时，新的状态值和旧的状态值对比，较快地定位到diff.<br>(2) v-for 遍历避免同时使用v-if<br>v-for比v-if优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当需要渲染很小一部分的时候，必要情况下应该替换为computed属性。<br>推荐：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">&lt;ul&gt;</span></span><br><span class="line">  &lt;li</span><br><span class="line">    v-<span class="keyword">for</span>=<span class="string">&quot;user in activeUsers&quot;</span></span><br><span class="line">    :key=<span class="string">&quot;user.id&quot;</span>&gt;</span><br><span class="line">    &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">computed: &#123;</span><br><span class="line">  activeUser<span class="variable">s:</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> this.users.<span class="built_in">filter</span>(<span class="function"><span class="keyword">function</span> <span class="params">(user)</span> &#123;</span></span><br><span class="line">   <span class="keyword">return</span> user.isActive</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">### 注意：computed中activeUsers不能和data中属性重复</span><br></pre></td></tr></table></figure>
<p>不推荐：</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">  &lt;li</span></span><br><span class="line"><span class="xml">    v-for=&quot;user in users&quot;</span></span><br><span class="line"><span class="xml">    v-if=&quot;user.isActive&quot;</span></span><br><span class="line"><span class="xml">    :key=&quot;user.id&quot;&gt;</span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123; <span class="name">user.name</span> &#125;&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="长列表性能优化"><a href="#长列表性能优化" class="headerlink" title="长列表性能优化"></a>长列表性能优化</h4><p>Vue会通过Object.defineProperty对数据进行劫持，来实现视图相应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要Vue来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止Vue劫持我们的数据呢？可以通过Object.freeze方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> &#123;</span><br><span class="line">  data: () =&gt; (&#123;</span><br><span class="line">    users: &#123;&#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  async created() &#123;</span><br><span class="line">    const users = await axios.<span class="keyword">get</span>(&quot;/api/users&quot;);</span><br><span class="line">    this.users = <span class="keyword">Object</span>.<span class="keyword">freeze</span>(users);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="事件的销毁"><a href="#事件的销毁" class="headerlink" title="事件的销毁"></a>事件的销毁</h4><p>Vue组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。如果在js内：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">created<span class="literal">()</span> &#123;</span><br><span class="line">  add<span class="constructor">EventListener(&#x27;<span class="params">click</span>&#x27;, <span class="params">this</span>.<span class="params">click</span>, <span class="params">false</span>)</span></span><br><span class="line">&#125;,</span><br><span class="line">before<span class="constructor">Destroy()</span> &#123;</span><br><span class="line">  remove<span class="constructor">EventListener(&#x27;<span class="params">click</span>&#x27;, <span class="params">this</span>.<span class="params">click</span>, <span class="params">false</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="图片资源懒加载"><a href="#图片资源懒加载" class="headerlink" title="图片资源懒加载"></a>图片资源懒加载</h4><p>对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载，等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用Vue的<code>vue-lazyload</code>插件:<br>（1）安装插件</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-lazyload --<span class="built_in">save</span>-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure>
<p>（2）在入口文件main.js中引入并使用</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueLazyload <span class="keyword">from</span> <span class="string">&#x27;vue-lazyload&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后在vue中直接使用</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Vue</span>.</span></span>use(VueLazyload)</span><br></pre></td></tr></table></figure>
<p>或者添加自定义选项</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(VueLazyload, &#123;</span><br><span class="line">preLoad: 1.3,</span><br><span class="line"><span class="keyword">error: </span>&#x27;dist/error.png&#x27;,</span><br><span class="line">loading: &#x27;dist/loading.gif&#x27;,</span><br><span class="line">attempt: 1Î</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>(3) 在vue文件中将img标签的src属性直接改为v-lazy，从而将图片显示方式更改为懒加载显示：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img <span class="attribute">v-lazy</span>=<span class="string">&quot;/static/img/1.png&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>以上为vue-lazyload插件的简单使用，如果要看插件的更多参数选项，可以查看vue-lazyload的GitHub地址。</p>
<h4 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h4><p> Vue是单页面应用，可能会有很多的路由引入，这样使用webpack打包后的文件很大，当进入首页是，加载的资源过多，页面会出现白屏的情况，不利于用户体验。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。<br> 路由懒加载：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const Foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./Foo.vue&#x27;</span>)</span><br><span class="line">const router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: <span class="string">&#x27;/foo&#x27;</span>, component: Foo &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="第三方插件的按需引入"><a href="#第三方插件的按需引入" class="headerlink" title="第三方插件的按需引入"></a>第三方插件的按需引入</h4><p>我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助babel-plugin-compontent，然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入element-ui组件库为例：<br>（1）首先，安装babel-plugin-component；</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install </span><span class="keyword">babel-plugin-component </span>-D</span><br></pre></td></tr></table></figure>
<p>(2) 然后，将.babelrc修改为：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [[<span class="string">&quot;es2015&quot;</span>, &#123; <span class="attr">&quot;modules&quot;</span>: <span class="literal">false</span> &#125;]],</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;component&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;libraryName&quot;</span>: <span class="string">&quot;element-ui&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;styleLibraryName&quot;</span>: <span class="string">&quot;theme-chalk&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）在main.js中引入部分组件:</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button, <span class="keyword">Select</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"></span><br><span class="line"> Vue.use(Button)</span><br><span class="line"> Vue.use(<span class="keyword">Select</span>)</span><br></pre></td></tr></table></figure>
<h4 id="优化无限列表性能"><a href="#优化无限列表性能" class="headerlink" title="优化无限列表性能"></a>优化无限列表性能</h4><p>如果你的应用存在非常长或者无限滚动的列表，那么需要采用窗口话的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建dom节点的时间。你可以参考下开源项目vue-virtual-scroll-list和vue-virtual-scroller来优化这种无限列表的场景的。</p>
<h4 id="服务端渲染SSR-or-预渲染"><a href="#服务端渲染SSR-or-预渲染" class="headerlink" title="服务端渲染SSR or 预渲染"></a>服务端渲染SSR or 预渲染</h4><p>服务端渲染是指Vue在客户端将标签渲染成的整个HTML片段的工作在服务端完成，服务端形成的HTML片段直接返回给客户端这个过程就叫做服务端渲染。<br>（1）服务端渲染的优点：<br>  更好的SEO：因为SPA页面的内容是通过Ajax获取，而搜索引擎爬取工具并不会等待Ajax异步完成后再抓取页面内容，所以在SPA中是抓取不到页面通过Ajax获取到的内容；<br>  而SSR是直接有服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</p>
<p>  更快的内容到达时间（首屏加载更快）：SPA会等待所有Vue编译后的js文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；<br>  SSR直接由服务端渲染好页面直接返回显示，无需等待下载js文件及再去渲染等，所以SSR有更快的内容到达时间；<br>（2）服务端渲染的缺点：<br>  更多的开发条件限制：例如服务端渲染只支持beforeCreate和created两个钩子函数，这回导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序SPA不同，服务端渲染应用程序，需要处于Node.js server 运行环境；<br>  更多的服务器负载：在Node.js中渲染完整的应用程序，显然会比仅仅提供静态文件的server更加大量占用CPU资源，因此如果你预料在高流量环境下使用，请准备相应的服务器负载，并明智的采用缓存战略。<br>如果你的项目的SEO和首屏渲染是评价项目的关键指标，那么你的项目就需要服务端渲染来帮助你实现最佳的初始加载性能和SEO,具体的Vue SSR如何实现，可以参考作者的另一篇文章《Vue SSR踩坑之旅》。如果你的Vue项目只需改善少数营销页面（例如/,/about,/contact等）的SEO，那么你可能需要预渲染，在构建时（build time）简单的生成针对特定路由的静态HTML文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点，具体你可以使用prerender-spa-plugin就可以轻松添加预渲染。</p>
<p><code>https://blog.csdn.net/xustart7720/article/details/79960591</code>[web前端性能&amp;SEO优化]</p>
<h3 id="Webpack层面的优化"><a href="#Webpack层面的优化" class="headerlink" title="Webpack层面的优化"></a>Webpack层面的优化</h3><h4 id="Webpack对图片进行压缩"><a href="#Webpack对图片进行压缩" class="headerlink" title="Webpack对图片进行压缩"></a>Webpack对图片进行压缩</h4><p>在Vue项目中除了可以在webpack.base.conf.js中url-loader中设置limit大小来对图片处理，对小于limit的图片转为base64格式，其余的不做操作。所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用image-webpack-loader来压缩图片：<br>（1）首先，安装image-webpack-loader:</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install <span class="built_in">image</span>-webpack-loader --<span class="built_in">save</span>-dev</span><br></pre></td></tr></table></figure>
<p>(2) 然后，在webpack.base.conf.js中进行配置：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.(<span class="name">png</span>|jpe?g|gif|svg)(\?.*)?$/,</span><br><span class="line">  use:[</span><br><span class="line">    &#123;</span><br><span class="line">    loader: &#x27;url-loader&#x27;,</span><br><span class="line">    options: &#123;</span><br><span class="line">      limit: <span class="number">10000</span>,</span><br><span class="line">      name: utils.assetsPath(<span class="name">&#x27;img/</span>[name].[hash:7].[ext]&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: &#x27;image-webpack-loader&#x27;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        bypassOnDebug: <span class="literal">true</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="减少ES6转为ES5的亢余代码"><a href="#减少ES6转为ES5的亢余代码" class="headerlink" title="减少ES6转为ES5的亢余代码"></a>减少ES6转为ES5的亢余代码</h4><p>Babel插件会在将ES6代码转换为ES5代码时会注入一下辅助函数，例如下面的ES6代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWebpack</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码再被转换成能正常运行的ES5代码时需要以下两个辅助函数：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">babel-runtime<span class="regexp">/helpers/</span>createClass  <span class="regexp">//</span> 用于实现 class 语法</span><br><span class="line">babel-runtime<span class="regexp">/helpers/i</span>nherits  <span class="regexp">//</span> 用于实现 extends 语法</span><br></pre></td></tr></table></figure>
<p>在默认情况下，Babel会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码亢余。为了不让这些辅助函数的代码重复出现，可以在依赖它们是通过<code>require(&#39;babel-runtime/helpers/createClass)</code>的方式导入，这样就能做到只让它们出现一次。babel-plugin-transform-runtime插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小babel编译出来的代码的文件大小。<br>（1）首先，安装babel-plugin-transform-runtime:</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-plugin-<span class="built_in">transform</span>-runtime --<span class="built_in">save</span>-dev</span><br></pre></td></tr></table></figure>
<p>(2) 然后，修改.babelrc配置文件为：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;transform-runtime&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>如果要看插件的更多详细内容，可以查看babel-plugin-transform-runtime 的 详细介绍。</p>
<h4 id="提取公共代码"><a href="#提取公共代码" class="headerlink" title="提取公共代码"></a>提取公共代码</h4><p>如果项目中没有去将每个页面的第三方库和公共模块提取出来，则项目会存在以下问题：<br>  相同的资源被重复加载，浪费用户的流量和服务器的成本。<br>  每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。<br>所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题。Webpack内置了专门用于提取多个Chunk中的公共部分的插件CommonsChunkPlugin，我们在项目中CommonsChunkPlugin 的配置如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。</span></span><br><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">&#x27;vendor&#x27;</span>,</span><br><span class="line">  minChunks: <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, count</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="built_in">module</span>.resource &amp;&amp;</span><br><span class="line">      /\.js$/.test(<span class="built_in">module</span>.resource) &amp;&amp;</span><br><span class="line">      <span class="built_in">module</span>.resource.indexOf(</span><br><span class="line">        path.join(__dirname, <span class="string">&#x27;../node_modules&#x27;</span>)</span><br><span class="line">      ) === <span class="number">0</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;),</span><br><span class="line"><span class="comment">// 抽取出代码模块的映射关系</span></span><br><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">&#x27;manifest&#x27;</span>,</span><br><span class="line">  chunks: [<span class="string">&#x27;vendor&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line">参考[https:<span class="comment">//segmentfault.com/a/1190000012828879]</span></span><br></pre></td></tr></table></figure>
<p>如果要看插件的更多详细内容，可以查看 CommonsChunkPlugin 的 详细介绍。</p>
<h4 id="模板预编译"><a href="#模板预编译" class="headerlink" title="模板预编译"></a>模板预编译</h4><p>当使用DOM内模板或JavaScript内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。<br>预编译模板最简单的方式就是使用单文件组件—相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。<br>如果你使用Webpack，并且喜欢分离JavaScript和模板文件，你可以使用vue-templete-loader，它也可以在构建过程中把模板文件转换成为JavaScript渲染函数。</p>
<h4 id="提取组件的CSS"><a href="#提取组件的CSS" class="headerlink" title="提取组件的CSS"></a>提取组件的CSS</h4><p>当使用单组件时，组件内的CSS会以style标签的方式通过JavaScript动态注入。这有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段”无样式内容闪烁（fouc）”。将所有组件的CSS提取到同一个文件可以避免这个问题，也会让CSS更好地进行压缩和缓存。<br>查阅这个构建工具各自的文档来了解更多：<br>webpack+vue-loader（vue-cli的webpack模板已经预先配置好）<br>Browserify+vueify<br>Rollup+rollup-plugin-vue</p>
<h4 id="优化-SourceMap"><a href="#优化-SourceMap" class="headerlink" title="优化 SourceMap"></a>优化 SourceMap</h4><p>我们在项目就你行打包后，会将开放中的多个文件代码打包到一个文件中，并且经过压缩、去掉多余的空格、babel编译化后，最终将编译得到的代码会用于线上环境，那么这样处理后的代码和源代码会有很大的差别，当有bug的时候，我们只能定位到压缩处理后的代码位置，无法定位在开发环境中的代码，对于开发来说不好调试定位问题，因此sourceMap出现了，它就是为了解决不好调试代码问题的。<br>SourceMap的可选值如下（+好越多，代表速度越快，-号越多，代表速度越满，o代表中等速度）<br><img src="24.webp"><br>开发环境推荐：cheap-module-eval-source-map</p>
<p>生产环境推荐：cheap-module-source-map<br>原因如下：</p>
<p>cheap：源代码中的列信息是没有任何作用，因此我们打包后的文件不希望包含列相关信息，只有行信息能建立打包前后的依赖关系。因此不管是开发环境或生产环境，我们都希望添加 cheap 的基本类型来忽略打包前后的列信息；</p>
<p>module ：不管是开发环境还是正式环境，我们都希望能定位到bug的源代码具体的位置，比如说某个 Vue 文件报错了，我们希望能定位到具体的 Vue 文件，因此我们也需要 module 配置；</p>
<p>soure-map ：source-map 会为每一个打包后的模块生成独立的 soucemap 文件 ，因此我们需要增加source-map 属性；</p>
<p>eval-source-map：eval 打包代码的速度非常快，因为它不生成 map 文件，但是可以对 eval 组合使用 eval-source-map 使用会将 map 文件以 DataURL 的形式存在打包后的 js 文件中。在正式环境中不要使用 eval-source-map, 因为它会增加文件的大小，但是在开发环境中，可以试用下，因为他们打包的速度很快。</p>
<h4 id="构建结果输出分析"><a href="#构建结果输出分析" class="headerlink" title="构建结果输出分析"></a>构建结果输出分析</h4><p>Webpack 输出的代码可读性非常差而且文件非常大，让我们非常头疼。为了更简单、直观地分析输出结果，社区中出现了许多可视化分析工具。这些工具以图形的方式将结果更直观地展示出来，让我们快速了解问题所在。接下来讲解我们在 Vue 项目中用到的分析工具：webpack-bundle-analyzer 。<br>我们在项目中 webpack.prod.conf.js 进行配置：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (<span class="built_in">config</span>.<span class="keyword">build.bundleAnalyzerReport) </span>&#123;</span><br><span class="line">  var <span class="keyword">BundleAnalyzerPlugin </span>=   require(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>).<span class="keyword">BundleAnalyzerPlugin;</span></span><br><span class="line"><span class="keyword"> </span> webpackConfig.plugins.push(new <span class="keyword">BundleAnalyzerPlugin());</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br><span class="line"><span class="keyword"></span></span><br></pre></td></tr></table></figure>
<p>执行  $ npm run build –report  后生成分析报告如下：<br><img src="25.gif"></p>
<h4 id="Vue项目的编译优化"><a href="#Vue项目的编译优化" class="headerlink" title="Vue项目的编译优化"></a>Vue项目的编译优化</h4><p>如果你的 Vue 项目使用 Webpack 编译，需要你喝一杯咖啡的时间，那么也许你需要对项目的 Webpack 配置进行优化，提高 Webpack 的构建效率。具体如何进行 Vue 项目的 Webpack 构建优化，可以参考作者的另一篇文章《 Vue 项目 Webpack 优化实践》。</p>
<h3 id="基础的Web技术优化"><a href="#基础的Web技术优化" class="headerlink" title="基础的Web技术优化"></a>基础的Web技术优化</h3><h4 id="开启gzip压缩"><a href="#开启gzip压缩" class="headerlink" title="开启gzip压缩"></a>开启gzip压缩</h4><p>gzip 是 GNUzip 的缩写，最早用于 UNIX 系统的文件压缩。HTTP 协议上的 gzip 编码是一种用来改进 web 应用程序性能的技术，web 服务器和客户端（浏览器）必须共同支持 gzip。目前主流的浏览器，Chrome，firefox，IE等都支持该协议。常见的服务器如 Apache，Nginx，IIS 同样支持，gzip 压缩效率非常高，通常可以达到 70% 的压缩率，也就是说，如果你的网页有 30K，压缩之后就变成了 9K 左右。<br>以下我们以服务端使用我们熟悉的 express 为例，开启 gzip 非常简单，相关步骤如下：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">安装：</span><br><span class="line"></span><br><span class="line">npm install compression --<span class="keyword">save</span></span><br><span class="line">添加代码逻辑：</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> compression = require(&#x27;compression&#x27;);</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">app</span> = express();</span><br><span class="line"><span class="keyword">app</span>.<span class="keyword">use</span>(compression())</span><br><span class="line"></span><br><span class="line">重启服务，观察网络面板里面的 response header，如果看到如下红圈里的字段则表明 gzip 开启成功 ：</span><br></pre></td></tr></table></figure>
<h4 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h4><p>为了提高用户加载页面的速度，对静态资源进行缓存是非常必要的，根据是否需要重新向服务器发起请求来分类，将 HTTP 缓存规则分为两大类（强制缓存，对比缓存），如果对缓存机制还不是了解很清楚的，可以参考作者写的关于 HTTP 缓存的文章《深入理解HTTP缓存机制及原理》，这里不再赘述。</p>
<h4 id="CDN-的使用"><a href="#CDN-的使用" class="headerlink" title="CDN 的使用"></a>CDN 的使用</h4><p>浏览器从服务器上下载 CSS、js 和图片等文件时都要和服务器连接，而大部分服务器的带宽有限，如果超过限制，网页就半天反应不过来。而 CDN 可以通过不同的域名来加载文件，从而使下载文件的并发连接数大大增加，且CDN 具有更好的可用性，更低的网络延迟和丢包率 。</p>
<h4 id="使用-Chrome-Performance-查找性能瓶颈"><a href="#使用-Chrome-Performance-查找性能瓶颈" class="headerlink" title="使用 Chrome Performance 查找性能瓶颈"></a>使用 Chrome Performance 查找性能瓶颈</h4><p>Chrome 的 Performance 面板可以录制一段时间内的 js 执行细节及时间。使用 Chrome 开发者工具分析页面性能的步骤如下。</p>
<p>1、打开 Chrome 开发者工具，切换到 Performance 面板</p>
<p>2、点击 Record 开始录制</p>
<p>3、刷新页面或展开某个节点</p>
<p>4、点击 Stop 停止录制</p>
<p>原文链接：<code>https://blog.csdn.net/qq_37939251/article/details/100031285</code></p>
</div><div class="tags"><a href="/tags/Vue/"><i class="fa fa-tag"></i>Vue</a></div><div class="post-nav"><a class="pre" href="/2021/07/26/ES5%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/">ES5实现继承</a><a class="next" href="/2021/07/22/vue%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%B9%B6%E6%93%8D%E4%BD%9CDOM%E5%85%83%E7%B4%A0/">Vue如何获取并操作DOM元素</a></div><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/sukkaw/disqusjs/dist/disqusjs.css?v=1.0.0"><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/sukkaw/disqusjs/dist/disqus.js?v=1.0.0"></script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });</script><div class="comments" id="disqus_thread"><script type="text/javascript">// Load comments with DisqusJS
function loadComments() {
  window.dsqjs = new DisqusJS({
    shortname: '',
    siteName: 'Monster',
    identifier: '2021/07/22/Vue项目性能优化方案/',
    url: 'https://liuhf666.github.io/2021/07/22/Vue项目性能优化方案/',
    title: 'Vue项目性能优化方案',
    api: '',
    apikey: '',
    admin: '',
    adminLabel: ''
  });
}
// Lazy load {# Credit: https://github.com/theme-next/hexo-theme-next/blob/master/layout/_third-party/comments/disqus.swig #}
(function () {
  var offsetTop = document.getElementById('disqus_thread').offsetTop - window.innerHeight;
  if (offsetTop <= 0) {
    // Load directly when there's no scrollbar
    window.addEventListener('load', loadComments, false);
  } else {
    var disqusScroll = function () {
      // offsetTop may changes because of manually resizing browser window or lazy loading images
      var offsetTop = document.getElementById('disqus_thread').offsetTop - window.innerHeight;
      var scrollTop = window.scrollY;

      // Pre-load comments a bit? (margin or anything else)
      if (offsetTop - scrollTop < 60) {
        window.removeEventListener('scroll', disqusScroll);
        loadComments();
      }
    };
    window.addEventListener('scroll', disqusScroll);
  }
})();
// Scroll to comments automatically if #comment-xxx anchor specified
window.addEventListener('load', function () {
  // I don't know why, it just works.
  window.setTimeout(function () {
    if (location.hash.indexOf('#comment-') !== -1) {
      document.getElementById('disqus_thread').scrollIntoView(true);
    }
  }, 100);
}, false);
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://liuhf666.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ES5/">ES5</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web%E9%9D%A2%E7%BB%8F/">Web面经</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8E%9F%E5%9E%8B%E9%93%BE/">原型链</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B7%B1-%E6%B5%85%E6%8B%B7%E8%B4%9D/">深&浅拷贝</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/07/26/ES5%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/">ES5实现继承</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/22/Vue%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/">Vue项目性能优化方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/22/vue%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%B9%B6%E6%93%8D%E4%BD%9CDOM%E5%85%83%E7%B4%A0/">Vue如何获取并操作DOM元素</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/21/HTTP%E5%92%8CHTTPS/">HTTP和HTTPS</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/09/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/">深拷贝和浅拷贝</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/08/%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8A%E7%9A%84%E9%82%A3%E4%BA%9B-%E5%AD%A6%E9%97%AE/">原型链上的那些[学问]</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/26/web%E5%A4%A7%E5%8E%82%E9%9D%A2%E7%BB%8F-%E9%98%BF%E9%87%8C-%E4%B8%80/">web大厂面经-阿里-一</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/23/web%E5%A4%A7%E5%8E%82%E9%9D%A2%E7%BB%8F-%E8%8A%82%E7%82%B9-%E5%85%AD/">web大厂面经-字节(六)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/16/web%E5%A4%A7%E5%8E%82%E9%9D%A2%E7%BB%8F-%E5%AD%97%E8%8A%82-%E4%BA%94/">web大厂面经-字节(五)</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/03/15/web%E5%A4%A7%E5%8E%82%E9%9D%A2%E7%BB%8F%E5%9B%9B/">web大厂面经-字节(四)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://liuhf666.github.io/" title="liuhf" target="_blank">liuhf</a><ul></ul><a href="https://github.com/liuhf666/liuhf666.github.io.git" title="Git" target="_blank">Git</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">Monster.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" color="255,0,0" opacity="0.7" zIndex="-1" count="88" src="//cdn.jsdelivr.net/npm/canvas-nest.js/dist/canvas-nest.min.js"></script><script type="text/javascript" src="/js/love.js"></script><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>